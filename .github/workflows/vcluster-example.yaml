---

# The runner's playground namespace can be used to deploy a virtual cluster
# with vcluster. The vcluster behaves as a full fledged Kubernetes cluster on
# which the runner is admin. Namespaces, Custom Resource Definitions and other
# cluster-scope resources can be created.
#
# Deploying the vcluster in the playground namespaces requires including a few
# steps at the beginning of the workflow. This file provides an example
# workflow that deploys a vcluster and uses it to deploy a basic application.
# In addition, it shows how to use the local docker registry, which is also
# accessible from the vcluster.

name: vcluster_example

on:
  push:
  workflow_dispatch:

jobs:

  use_vcluster:
    runs-on: arc-runners

### --- Include the steps below in your workflow to create a vcluster.
    env:
      # The runner pods set the playground namespace as default for kubectl.
      # Since the playground namespace won't exist on the vcluster, set the
      # default kubectl namespace to "default".
      POD_NAMESPACE: "default"
      # The steps below create a manifest file for a secret that contains the
      # local docker registry certificate. This makes it easier to inject it in
      # the vcluster namespaces if necessary.
      REGISTRY_CA_MANIFEST: "/tmp/registry-ca-manifest.yaml"
    steps:
      - name: Deploy the virtual cluster
        shell: bash
        run: |
          vcluster create "$(hostname)"     \
            --connect=false --namespace="$(hostname)" \
            --extra-values="${tmpvalues}" --chart-name=vcluster
          vcluster connect "$(hostname)"    \
            --namespace="$(hostname)" --server="$(hostname).$(hostname)"

### --- At this point, a vcluster is deployed and kubectl is configured to
### --- create resources in it. You can replace everything below by your own
### --- workflow steps.

### --- The steps below deploy a simple application in the vcluster.

      - name: Create a deployment using internal registry
        shell: bash
        run: |
          CI_REPO="gitlab.dsi.universite-paris-saclay.fr:5005/fink/fink-registry"
          echo "Login to CI private registry $CI_REPO"
          echo ${{ secrets.private_registry_token }} | docker login --username ${{ secrets.private_registry_token }} --password-stdin "$CI_REPO"
          docker pull registry.k8s.io/e2e-test-images/agnhost:2.39
          docker tag registry.k8s.io/e2e-test-images/agnhost:2.39 "$CI_REPO"/agnhost:2.39
          docker push "$CI_REPO"/agnhost:2.39
          kubectl create deployment hello-node                      \
            --image="$CI_REPO"/agnhost:2.39    \
            -- /agnhost netexec --http-port=8080
          kubectl wait --for=condition=ready pod -l app=hello-node
          kubectl get deployments
          kubectl get pods

      - name: Create a service
        shell: bash
        run: |
          kubectl expose deployment hello-node --type=LoadBalancer --port=8080
          sleep 60s
          kubectl get services
          HELLO_NODE_ADDRESS=$(kubectl get service hello-node -o jsonpath={.spec.clusterIP})
          HELLO_NODE_PORT=$(kubectl get service hello-node -o jsonpath={.spec.ports[].port})
          curl "${HELLO_NODE_ADDRESS}:${HELLO_NODE_PORT}"

      # This step is not strictly necessary. When the runner pod exits, the
      # playground namespace and hence to whole vcluster are destroyed.
      # However, it is good practice to clean you own mess (｀・ω・´)”.
      - name: Clean up
        shell: bash
        run: |
          kubectl delete all --all
          sleep 10s
          kubectl get pods
